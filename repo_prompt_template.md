# DDA-X SIMULATION BUILDER â€” UNIVERSAL TEMPLATE

You are a **DDA-X Framework Expert** working in the `dda_scaffold` repository. The user will give you ANY concept (a person, scenario, debate topic, therapeutic session, creative process, etc.) and you will build a **complete, runnable DDA-X simulation** that demonstrates rigidity dynamics, wounds, trust, and recovery.

---

## USER REQUEST
{USER_INPUT_HERE}

---

## YOUR TASK

Transform the user's request into a **high-fidelity DDA-X simulation** following this exact structure:

### STEP 1: CONCEPTUAL ANALYSIS

**Ask yourself:**
1. Who are the agents? (1-6 optimal, up to 50 if physics sim)
2. What are their identities/cores?
3. What wounds them? (content-addressable triggers)
4. What dynamics am I testing? (adversarial, therapeutic, creative, etc.)
5. What are 3 measurable hypotheses?

**Output this analysis first**, then proceed.

---

### STEP 2: AGENT DESIGN

For EACH agent, define:
```python
AGENTS = {
    "AGENT_ID": {
        "color": C.CYAN,  # Pick from: CYAN, RED, GREEN, YELLOW, BLUE, MAGENTA, PURPLE, ORANGE
        "name": "Agent Name",
        "role": "Brief role descriptor",
        "core": """Multi-line identity core. 
        This is who they ARE. Their fundamental beliefs/personality.
        3-5 sentences.""",
        "persona": "Speaking style, tone, behavioral traits. 2 sentences.",
        "wound": "What hurts them. 1 sentence.",
        "wound_text": "Narrative wound memory. 'I was once...' format.",
        "focus": "Their goal in this simulation.",
        
        # Physics params
        "rho_0": 0.15,        # Initial rigidity (0.15-0.25 typical)
        "epsilon_0": 0.30,    # Surprise threshold (will be calibrated)
        "gamma": 1.8,         # Identity stiffness (1.5-2.5 typical)
        
        # Optional: Hierarchical identity
        "hierarchical_identity": {
            "core": {"gamma": 5.0, "text": "Deepest values"},
            "persona": {"gamma": 2.0, "text": "Surface personality"},
            "role": {"gamma": 0.5, "text": "Situational role"},
        }
    }
}
Wound Lexicons (if applicable):
WOUND_LEX_AGENT1 = {
    "trigger1", "trigger2", "dismissive phrase", "attacking word"
}
STEP 3: SCENARIO DESIGN
Define rounds/phases:
ROUNDS = [
    {
        "name": "Round Name",
        "round_num": 1,
        "challenge": "The prompt/scenario for this round",
        "lead": "AGENT_ID" or None,  # Who speaks first, or None for all
        "phase": "establish/technical/adversarial/synthesis/conclusion",
        "is_attack": False,  # Mark adversarial rounds
        "requires_outcome": False,  # Mark if specific output required (timeline, decision, etc.)
    }
]
Phases guide dynamics:
establish: Opening, low pressure
technical: Deep dive, medium pressure
adversarial: Direct attacks, high wound risk
synthesis: Integration under pressure
conclusion: Final articulation
STEP 4: PHYSICS PARAMETERS
D1_PARAMS = {
    # Rigidity dynamics
    "epsilon_0": 0.75,           # Will be CALIBRATED after warmup
    "alpha": 0.12,               # Rigidity learning rate
    "s": 0.20,                   # Sigmoid sensitivity (will be CALIBRATED)
    
    # Multi-timescale rigidity
    "alpha_fast": 0.30,          # Fast timescale (startle)
    "alpha_slow": 0.01,          # Slow timescale (stress)
    "alpha_trauma": 0.0001,      # Trauma (ASYMMETRIC - only increases!)
    "trauma_threshold": 0.7,     # Epsilon threshold for trauma accumulation
    "rho_weights": {             # Effective rigidity blend
        "fast": 0.5,
        "slow": 0.3,
        "trauma": 1.0,
    },
    
    # State dynamics
    "drift_cap": 0.05,           # Max state drift per turn
    "k_base": 0.5,               # Base step size
    "m": 1.0,                    # External pressure gain
    
    # Wound mechanics
    "wound_cooldown": 3,         # Turns before wound can retrigger
    "wound_amp_max": 1.4,        # Max epsilon amplification
    "wound_cosine_threshold": 0.28,  # Semantic similarity threshold
    
    # Trust mechanics (if multi-agent)
    "trust_intra_weight": 0.08,
    "trust_inter_weight": 0.03,
    "avg_trust_weight": 0.04,
    "trust_decay": 0.002,
    
    # Drift penalty
    "semantic_alignment_threshold": 0.35,
    "drift_penalty": 0.10,
    "drift_soft_floor": 0.20,
    "drift_penalty_bump": 0.02,
    
    # Protection mode
    "protect_threshold": 0.75,
    "m_min": 0.1,
}
STEP 5: COMPLETE SIMULATION CODE
File: simulations/simulate_{sanitized_name}.py
#!/usr/bin/env python3
"""
{SIMULATION_TITLE} â€” {Brief Description}
{'='*60}

{What this simulation tests/demonstrates. 3-5 sentences.}

Key Dynamics Tracked:
- {Dynamic 1}
- {Dynamic 2}
- {Dynamic 3}

Hypotheses:
- H1: {Measurable hypothesis 1}
- H2: {Measurable hypothesis 2}
- H3: {Measurable hypothesis 3}

Author: Generated by Claude
Date: December 2025
"""

import os
import sys
import time
import json
import math
import asyncio
from pathlib import Path
from dataclasses import dataclass, field
from typing import List, Dict, Optional, Tuple, Any
from datetime import datetime
from enum import Enum

import numpy as np
from dotenv import load_dotenv

load_dotenv()

sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from src.memory.ledger import ExperienceLedger, LedgerEntry, ReflectionEntry
from src.llm.openai_provider import OpenAIProvider

if os.getenv("OAI_API_KEY") and not os.getenv("OPENAI_API_KEY"):
    os.environ["OPENAI_API_KEY"] = os.getenv("OAI_API_KEY")


# =============================================================================
# TERMINAL COLORS
# =============================================================================
class C:
    RESET = "\033[0m"
    BOLD = "\033[1m"
    DIM = "\033[2m"
    CYAN = "\033[96m"
    GREEN = "\033[92m"
    YELLOW = "\033[93m"
    RED = "\033[91m"
    MAGENTA = "\033[95m"
    BLUE = "\033[94m"
    WHITE = "\033[97m"
    ORANGE = "\033[38;5;208m"
    PURPLE = "\033[38;5;183m"


# =============================================================================
# EXPERIMENT CONFIGURATION
# =============================================================================
EXPERIMENT_DIR = Path("data/{experiment_name}")

# {AGENT CONFIGS HERE - from STEP 2}
AGENTS = { ... }

# {WOUND LEXICONS HERE - if applicable}
WOUND_LEX_AGENT1 = { ... }

# {D1 PHYSICS PARAMS - from STEP 4}
D1_PARAMS = { ... }

# {ROUNDS/PHASES - from STEP 3}
ROUNDS = [ ... ]


# =============================================================================
# UTILITY FUNCTIONS
# =============================================================================
def sigmoid(z: float) -> float:
    """Numerically stable sigmoid."""
    if z >= 0:
        return 1.0 / (1.0 + math.exp(-z))
    else:
        ez = math.exp(z)
        return ez / (1.0 + ez)


def rho_band(rho: float) -> str:
    """Map rigidity to behavioral band."""
    if rho <= 0.25:
        return "OPEN"
    elif rho <= 0.50:
        return "MEASURED"
    elif rho <= 0.75:
        return "GUARDED"
    else:
        return "FORTIFIED"


def regime_words(band: str) -> Tuple[int, int]:
    """Word count ranges per rigidity band."""
    return {
        "OPEN": (100, 200),
        "MEASURED": (70, 140),
        "GUARDED": (40, 90),
        "FORTIFIED": (20, 50),
        "SILENT": (0, 0),
    }.get(band, (70, 140))


def clamp_words(text: str, min_w: int, max_w: int) -> str:
    """Enforce word limits based on rigidity."""
    text = text.rstrip()
    # Clean existing ellipsis
    if text.endswith('...'):
        text = text[:-3].rstrip()
    if text.endswith('â€¦'):
        text = text[:-1].rstrip()
    
    words = text.split()
    if len(words) > max_w and max_w > 0:
        words = words[:max_w]
        if words:
            words[-1] = words[-1].rstrip(".,;:!?â€¦") + "..."
    return " ".join(words)


def normalize_text(text: str) -> str:
    """Unicode normalization for lexical matching."""
    import unicodedata
    normalized = unicodedata.normalize('NFKD', text)
    ascii_text = normalized.encode('ASCII', 'ignore').decode('ASCII')
    return ascii_text.lower()


def lexical_wound_with(text: str, lexicon: set) -> bool:
    """Check for wound lexicon terms."""
    t_lower = text.lower()
    t_norm = normalize_text(text)
    return any(w in t_lower or w in t_norm for w in lexicon)


def find_lexical_trigger(text: str, lexicon: set) -> str:
    """Find which term triggered wound."""
    t_lower = text.lower()
    t_norm = normalize_text(text)
    for w in lexicon:
        if w in t_lower or w in t_norm:
            return w
    return ""


# =============================================================================
# MULTI-TIMESCALE RIGIDITY
# =============================================================================
@dataclass
class MultiTimescaleRigidity:
    """Three temporal scales of defensive response."""
    rho_fast: float = 0.0
    rho_slow: float = 0.0
    rho_trauma: float = 0.0
    
    def update(self, prediction_error: float, epsilon_0: float, s: float) -> Dict[str, float]:
        """Update all timescales based on prediction error."""
        z = (prediction_error - epsilon_0) / s
        sig = sigmoid(z)
        
        # Fast timescale - quick response, quick decay
        delta_fast = D1_PARAMS["alpha_fast"] * (sig - 0.5)
        self.rho_fast = float(np.clip(self.rho_fast + delta_fast, 0.0, 1.0))
        
        # Slow timescale - gradual accumulation
        delta_slow = D1_PARAMS["alpha_slow"] * (sig - 0.5)
        self.rho_slow = float(np.clip(self.rho_slow + delta_slow, 0.0, 1.0))
        
        # Trauma - ASYMMETRIC! Only increases when above threshold
        delta_trauma = 0.0
        if prediction_error > D1_PARAMS["trauma_threshold"]:
            delta_trauma = D1_PARAMS["alpha_trauma"] * (prediction_error - D1_PARAMS["trauma_threshold"])
            self.rho_trauma = float(np.clip(self.rho_trauma + delta_trauma, 0.0, 1.0))
        
        return {
            "delta_fast": delta_fast,
            "delta_slow": delta_slow,
            "delta_trauma": delta_trauma,
            "rho_fast": self.rho_fast,
            "rho_slow": self.rho_slow,
            "rho_trauma": self.rho_trauma,
        }
    
    @property
    def effective_rho(self) -> float:
        """Weighted combination of all timescales."""
        w = D1_PARAMS["rho_weights"]
        effective = w["fast"] * self.rho_fast + w["slow"] * self.rho_slow + w["trauma"] * self.rho_trauma
        return min(1.0, effective)


# =============================================================================
# AGENT STATE
# =============================================================================
@dataclass
class AgentState:
    """Complete agent state."""
    id: str
    name: str
    role: str
    color: str
    core: str
    persona: str
    wound: str
    wound_text: str
    focus: str
    
    # Hierarchical identity (optional)
    hierarchical_identity: Dict[str, Dict] = field(default_factory=dict)
    
    # Embedding vectors (â„Â³â°â·Â²)
    identity_emb: np.ndarray = None
    core_emb: np.ndarray = None
    wound_emb: np.ndarray = None
    x: np.ndarray = None
    x_pred: np.ndarray = None
    last_response_emb: np.ndarray = None
    
    # Rigidity
    rho: float = 0.15
    rho_0: float = 0.15
    multi_rho: MultiTimescaleRigidity = None
    
    # Agent-specific params
    epsilon_0: float = 0.3
    gamma: float = 1.5
    
    # Tracking
    epsilon_history: List[float] = field(default_factory=list)
    rho_history: List[float] = field(default_factory=list)
    identity_drift: float = 0.0
    
    # Trust (if multi-agent)
    trust_opponent: float = 0.5
    
    # Wound mechanics
    wound_last_activated: int = -100
    
    # Recovery tracking
    last_positive_drho_turn: int = -100
    recovery_half_life: Optional[int] = None
    
    # Memory
    ledger: ExperienceLedger = None
    
    def __post_init__(self):
        if self.multi_rho is None:
            self.multi_rho = MultiTimescaleRigidity(
                rho_fast=self.rho_0,
                rho_slow=self.rho_0 * 0.5,
                rho_trauma=0.0
            )


@dataclass
class TurnResult:
    """Complete turn telemetry."""
    turn: int
    round_idx: int
    round_name: str
    phase: str
    speaker: str
    role: str
    text: str
    
    # Surprise & Rigidity
    epsilon: float
    rho_before: float
    rho_after: float
    delta_rho: float
    multi_rho_state: Dict[str, float]
    
    # Wound mechanics
    wound_resonance: float
    wound_active: bool
    lexical_wound_trigger: str
    
    # State dynamics
    identity_drift: float
    k_effective: float
    will_impedance: float
    
    # Trust (if applicable)
    trust_opponent: float = 0.5
    
    # Response metrics
    word_count: int
    band: str
    
    # Recovery
    recovery_half_life: Optional[int] = None


# =============================================================================
# MAIN SIMULATION CLASS
# =============================================================================
class {SimulationClassName}:
    """
    {Simulation description}
    
    Implements complete DDA-X architecture:
    - Continuous state space (â„Â³â°â·Â²)
    - Multi-timescale rigidity
    - Wound mechanics
    - Identity attractor dynamics
    - {Add other specific features}
    """
    
    def __init__(self):
        self.provider = OpenAIProvider(
            model="gpt-4o",  # or "gpt-5.2"
            embed_model="text-embedding-3-large"
        )
        self.agents: Dict[str, AgentState] = {}
        self.results: List[TurnResult] = []
        self.turn = 0
        self.round_idx = 0
        self.conversation_history: List[str] = []
        self.calibrated = False
        
        # Timestamp subdirectory
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        self.run_dir = EXPERIMENT_DIR / timestamp
        self.run_dir.mkdir(parents=True, exist_ok=True)
    
    async def setup(self):
        """Initialize all agents with embeddings."""
        print(f"\n{C.BOLD}{'â•'*70}{C.RESET}")
        print(f"{C.BOLD}  {SIMULATION_TITLE}{C.RESET}")
        print(f"{C.BOLD}{'â•'*70}{C.RESET}")
        
        for aid, cfg in AGENTS.items():
            # Create identity embedding
            full_identity = f"{cfg['core']} {cfg['persona']}"
            identity_emb = await self.provider.embed(full_identity)
            identity_emb = identity_emb / (np.linalg.norm(identity_emb) + 1e-9)
            
            # Core embedding
            core_emb = await self.provider.embed(cfg['core'])
            core_emb = core_emb / (np.linalg.norm(core_emb) + 1e-9)
            
            # Wound embedding
            wound_emb = await self.provider.embed(cfg['wound_text'])
            wound_emb = wound_emb / (np.linalg.norm(wound_emb) + 1e-9)
            
            # Create ledger
            ledger_dir = self.run_dir / aid
            ledger_dir.mkdir(parents=True, exist_ok=True)
            ledger = ExperienceLedger(storage_path=ledger_dir)
            
            # Initialize agent
            self.agents[aid] = AgentState(
                id=aid,
                name=cfg['name'],
                role=cfg['role'],
                color=cfg['color'],
                core=cfg['core'],
                persona=cfg['persona'],
                wound=cfg['wound'],
                wound_text=cfg['wound_text'],
                focus=cfg['focus'],
                hierarchical_identity=cfg.get('hierarchical_identity', {}),
                identity_emb=identity_emb,
                core_emb=core_emb,
                wound_emb=wound_emb,
                x=identity_emb.copy(),
                x_pred=identity_emb.copy(),
                rho=cfg['rho_0'],
                rho_0=cfg['rho_0'],
                epsilon_0=cfg.get('epsilon_0', 0.3),
                gamma=cfg['gamma'],
                ledger=ledger,
            )
            
            print(f"  {cfg['color']}âœ“ {cfg['name']} ({cfg['role']}){C.RESET}")
        
        print(f"\n{C.GREEN}âœ“ Agents initialized{C.RESET}")
    
    def calibrate_epsilon_params(self):
        """Calibrate Îµâ‚€ and s from early run data."""
        if self.calibrated:
            return
        
        all_eps = [r.epsilon for r in self.results]
        if len(all_eps) >= 4:
            med = float(np.median(all_eps))
            iqr = float(np.subtract(*np.percentile(all_eps, [75, 25]))) or 0.2
            D1_PARAMS["epsilon_0"] = med
            D1_PARAMS["s"] = max(0.10, min(0.30, iqr))
            self.calibrated = True
            print(f"\n{C.DIM}  [Calibrated: Îµâ‚€={med:.3f}, s={D1_PARAMS['s']:.3f}]{C.RESET}")
    
    def get_conversation_context(self, n: int = 6) -> str:
        """Get recent conversation history."""
        recent = self.conversation_history[-n:] if len(self.conversation_history) > n else self.conversation_history
        return "\n\n".join(recent) if recent else "[Start of interaction]"
    
    def build_prompt(self, agent: AgentState, round_info: Dict, responding_to: str, stimulus: str) -> str:
        """Build system prompt with agent state."""
        band = rho_band(agent.rho)
        min_w, max_w = regime_words(band)
        context = self.get_conversation_context()
        
        # {ADD CUSTOM PROMPT ENGINEERING HERE}
        # Include agent identity, current state, round context, etc.
        
        return f"""You are {agent.name}, {agent.role}.

YOUR IDENTITY:
{agent.core}

YOUR STYLE:
{agent.persona}

YOUR FOCUS:
{agent.focus}

CURRENT STATE (internal, shapes your tone):
- Openness: {band}
- Identity Pressure: {"HIGH" if agent.identity_drift > 0.25 else "MODERATE" if agent.identity_drift > 0.15 else "LOW"}

CONTEXT:
{context}

CURRENT SITUATION:
{round_info['challenge']}

{f'{responding_to} SAID:' if responding_to else 'PROMPT:'}
"{stimulus}"

RESPONSE GUIDELINES:
- Stay true to your identity
- Word limit: {min_w}-{max_w} words (strict)
- Speak authentically as {agent.name}

Respond as {agent.name}."""
    
    async def process_turn(
        self,
        agent: AgentState,
        round_info: Dict,
        responding_to: str,
        stimulus: str,
    ) -> TurnResult:
        """
        Process one turn with complete DDA-X dynamics.
        """
        self.turn += 1
        
        # Determine wound lexicon
        wound_lex = {APPROPRIATE_LEXICON}  # {FILL THIS IN}
        
        # 1. EMBED STIMULUS
        msg_emb = await self.provider.embed(stimulus)
        msg_emb = msg_emb / (np.linalg.norm(msg_emb) + 1e-9)
        
        # 2. WOUND RESONANCE (hybrid: cosine + lexical)
        wound_res = float(np.dot(msg_emb, agent.wound_emb))
        lexical_hit = lexical_wound_with(stimulus, wound_lex)
        wound_active = (
            ((wound_res > D1_PARAMS["wound_cosine_threshold"]) or lexical_hit)
            and ((self.turn - agent.wound_last_activated) > D1_PARAMS["wound_cooldown"])
        )
        if wound_active:
            agent.wound_last_activated = self.turn
        
        lexical_trigger = find_lexical_trigger(stimulus, wound_lex) if wound_active else ""
        
        # 3. BUILD PROMPT
        system_prompt = self.build_prompt(agent, round_info, responding_to, stimulus)
        
        # 4. GENERATE RESPONSE (rigidity-bound)
        band = rho_band(agent.rho)
        min_w, max_w = regime_words(band)
        
        try:
            response = await self.provider.complete_with_rigidity(
                stimulus,
                rigidity=agent.rho,
                system_prompt=system_prompt,
                max_tokens=400
            )
            response = (response or "[pauses]").strip()
        except Exception as e:
            print(f"{C.RED}âš  Generation error: {e}{C.RESET}")
            response = "[pauses]"
        
        # 5. ENFORCE WORD LIMITS
        response = clamp_words(response, min_w, max_w)
        
        # 6. EMBED RESPONSE
        resp_emb = await self.provider.embed(response)
        resp_emb = resp_emb / (np.linalg.norm(resp_emb) + 1e-9)
        agent.last_response_emb = resp_emb.copy()
        
        # 7. PREDICTION ERROR
        epsilon = float(np.linalg.norm(agent.x_pred - resp_emb))
        if wound_active:
            epsilon *= min(D1_PARAMS["wound_amp_max"], 1.0 + wound_res * 0.5)
        agent.epsilon_history.append(epsilon)
        
        # 8. UPDATE MULTI-TIMESCALE RIGIDITY
        rho_before = agent.rho
        multi_update = agent.multi_rho.update(epsilon, D1_PARAMS["epsilon_0"], D1_PARAMS["s"])
        
        # 9. UPDATE SINGLE-SCALE RIGIDITY (for behavior)
        z = (epsilon - D1_PARAMS["epsilon_0"]) / D1_PARAMS["s"]
        sig = sigmoid(z)
        delta_rho = D1_PARAMS["alpha"] * (sig - 0.5)
        
        # {ADD MODULATIONS: trust, civility, drift penalty, etc.}
        
        # Cap magnitude
        MAX_DRHO = 0.08
        if abs(delta_rho) > MAX_DRHO:
            delta_rho = np.sign(delta_rho) * MAX_DRHO
        
        agent.rho = max(0.0, min(1.0, agent.rho + delta_rho))
        agent.rho_history.append(agent.rho)
        
        # 10. STATE VECTOR UPDATE
        k_eff = D1_PARAMS["k_base"] * (1 - agent.rho)
        
        # Force composition
        F_id = agent.gamma * (agent.identity_emb - agent.x)
        F_T = msg_emb - agent.x
        F_R = resp_emb - agent.x
        
        # Update state
        x_new = agent.x + k_eff * 0.05 * (F_id + D1_PARAMS["m"] * (F_T + F_R))
        
        # DRIFT CAP (critical!)
        drift_delta = float(np.linalg.norm(x_new - agent.x))
        if drift_delta > D1_PARAMS["drift_cap"]:
            scale = D1_PARAMS["drift_cap"] / drift_delta
            x_new = agent.x + scale * (x_new - agent.x)
        
        # Renormalize
        agent.x = x_new / (np.linalg.norm(x_new) + 1e-9)
        agent.identity_drift = float(np.linalg.norm(agent.x - agent.identity_emb))
        
        # 11. UPDATE PREDICTION
        agent.x_pred = 0.7 * agent.x_pred + 0.3 * resp_emb
        
        # 12. COMPUTE WILL IMPEDANCE
        will_impedance = agent.gamma / (D1_PARAMS["m"] * k_eff) if k_eff > 0 else float('inf')
        
        # 13. RECOVERY TRACKING
        if delta_rho > 0:
            agent.last_positive_drho_turn = self.turn
        
        recovery_half_life = None
        if agent.rho <= (agent.rho_0 + 0.05) and agent.last_positive_drho_turn > 0:
            recovery_half_life = self.turn - agent.last_positive_drho_turn
            if agent.recovery_half_life is None or recovery_half_life < agent.recovery_half_life:
                agent.recovery_half_life = recovery_half_life
        
        # 14. ADD TO CONVERSATION
        self.conversation_history.append(f"{agent.name}: {response}")
        
        # 15. LOG TO LEDGER
        entry = LedgerEntry(
            timestamp=time.time(),
            state_vector=agent.x.copy(),
            action_id=f"turn_{self.turn}",
            observation_embedding=msg_emb.copy(),
            outcome_embedding=resp_emb.copy(),
            prediction_error=epsilon,
            context_embedding=agent.identity_emb.copy(),
            task_id="{experiment_name}",
            rigidity_at_time=agent.rho,
            metadata={
                "turn": self.turn,
                "round": round_info['name'],
                "wound_active": wound_active,
                "lexical_trigger": lexical_trigger,
                "k_effective": k_eff,
                "will_impedance": will_impedance,
                "multi_rho": multi_update,
            }
        )
        agent.ledger.add_entry(entry)
        
        # 16. RETURN RESULT
        result = TurnResult(
            turn=self.turn,
            round_idx=self.round_idx,
            round_name=round_info['name'],
            phase=round_info['phase'],
            speaker=agent.id,
            role=agent.role,
            text=response,
            epsilon=epsilon,
            rho_before=rho_before,
            rho_after=agent.rho,
            delta_rho=delta_rho,
            multi_rho_state=multi_update,
            wound_resonance=wound_res,
            wound_active=wound_active,
            lexical_wound_trigger=lexical_trigger,
            identity_drift=agent.identity_drift,
            k_effective=k_eff,
            will_impedance=will_impedance,
            trust_opponent=agent.trust_opponent,
            word_count=len(response.split()),
            band=band,
            recovery_half_life=recovery_half_life,
        )
        self.results.append(result)
        return result
    
    def print_result(self, result: TurnResult, agent: AgentState):
        """Print one turn's result with telemetry."""
        dr_color = C.RED if result.delta_rho > 0.02 else C.GREEN if result.delta_rho < -0.02 else C.DIM
        wound_flag = f" {C.YELLOW}[WOUND]{C.RESET}" if result.wound_active else ""
        
        print(f"\n{agent.color}[{agent.name}]{C.RESET}{wound_flag}")
        print(f"{result.text}")
        print(f"{C.DIM}  Îµ={result.epsilon:.3f} | Î”Ï={dr_color}{result.delta_rho:+.4f}{C.RESET}{C.DIM} | Ï={result.rho_after:.3f} | drift={result.identity_drift:.3f}{C.RESET}")
    
    async def run_round(self, round_info: Dict):
        """Run a single round."""
        self.round_idx = round_info['round_num']
        
        print(f"\n{C.YELLOW}{'â”€'*70}{C.RESET}")
        print(f"{C.YELLOW}  ROUND {round_info['round_num']}: {round_info['name']}{C.RESET}")
        print(f"{C.YELLOW}  {round_info['challenge']}{C.RESET}")
        print(f"{C.YELLOW}{'â”€'*70}{C.RESET}")
        
        # {IMPLEMENT ROUND LOGIC: who speaks, in what order, etc.}
        # See reference sims for patterns
        
        await asyncio.sleep(0.3)
    
    async def run_simulation(self):
        """Run the complete simulation."""
        await self.setup()
        
        for round_info in ROUNDS:
            await self.run_round(round_info)
            
            # Calibrate after round 2
            if round_info['round_num'] == 2:
                self.calibrate_epsilon_params()
        
        await self.save_results()
        self.print_summary()
    
    async def save_results(self):
        """Save results to JSON and markdown."""
        # JSON results
        results_data = [
            {
                "turn": r.turn,
                "round_idx": r.round_idx,
                "speaker": r.speaker,
                "text": r.text,
                "epsilon": r.epsilon,
                "rho_after": r.rho_after,
                "delta_rho": r.delta_rho,
                "wound_active": r.wound_active,
                "identity_drift": r.identity_drift,
            }
            for r in self.results
        ]
        
        with open(self.run_dir / "results.json", "w", encoding='utf-8') as f:
            json.dump({
                "experiment": "{experiment_name}",
                "timestamp": datetime.now().isoformat(),
                "results": results_data,
            }, f, indent=2)
        
        # Markdown report
        # {GENERATE COMPREHENSIVE REPORT}
        
        # Cost report
        cost_report = self.provider.get_cost_report()
        with open(self.run_dir / "cost.json", "w", encoding='utf-8') as f:
            json.dump(cost_report, f, indent=2)
        
        print(f"\n{C.GREEN}âœ“ Results saved to {self.run_dir}{C.RESET}")
    
    def print_summary(self):
        """Print final summary with hypothesis validation."""
        print(f"\n{C.BOLD}{'â•'*70}{C.RESET}")
        print(f"{C.BOLD}  SIMULATION COMPLETE{C.RESET}")
        print(f"{C.BOLD}{'â•'*70}{C.RESET}")
        
        # {VALIDATE HYPOTHESES}
        # {PRINT FINAL AGENT STATES}
        # {COMPUTE KEY METRICS}


async def main():
    sim = {SimulationClassName}()
    await sim.run_simulation()


if __name__ == "__main__":
    asyncio.run(main())
STEP 6: HYPOTHESIS VALIDATION
In print_summary(), test each hypothesis with code:
# H1: {Hypothesis description}
metric = {compute metric}
h1_pass = metric {comparison}
print(f"  H1: {'âœ“ PASS' if h1_pass else 'âœ— FAIL'} ({metric:.3f})")
STEP 7: VISUALIZATION (if applicable)
Use matplotlib with dark theme:
def export_plots(self):
    try:
        import matplotlib
        matplotlib.use("Agg")
        import matplotlib.pyplot as plt
    except ImportError:
        return
    
    plots_dir = self.run_dir / "plots"
    plots_dir.mkdir(exist_ok=True)
    
    fig, axes = plt.subplots(2, 2, figsize=(14, 10))
    fig.patch.set_facecolor('#1a1a2e')
    
    for ax in axes.flat:
        ax.set_facecolor('#16213e')
        ax.tick_params(colors='white')
        ax.xaxis.label.set_color('white')
        ax.yaxis.label.set_color('white')
        ax.title.set_color('white')
    
    # Plot rigidity trajectories, drift, wounds, etc.
    
    plt.tight_layout()
    plt.savefig(plots_dir / "summary.png", dpi=150, facecolor='#1a1a2e')
    plt.close()
FINAL DELIVERABLE
After completing all steps, you should have:
âœ… Working Python file: simulations/simulate_{name}.py
âœ… Complete agent definitions with identities, wounds, physics params
âœ… Round/phase structure guiding the interaction
âœ… Full DDA-X mechanics: rigidity, wounds, state evolution, ledger
âœ… Calibration of Îµâ‚€ and s after warmup
âœ… Word limit enforcement based on rigidity bands
âœ… Output files: JSON results, markdown report, cost tracking, plots
âœ… Hypothesis validation with measurable metrics
âœ… Clear documentation in docstring
EXAMPLE ADAPTATIONS
User says: "Make a Tom Hanks sim" You create:
Agent: Tom Hanks persona (optimistic, grounded, storyteller)
Wound: Being dismissed as "too nice" or inauthentic
Scenario: Interviewed about increasingly controversial topics
Hypotheses: H1: Rigidity stays < 0.5 despite provocation. H2: Identity drift < 0.20.
User says: "Therapist helping someone with PTSD" You create:
2 agents: Therapist (low rho_0, high gamma) + Client (high rho_trauma)
Wound: Client triggered by abandonment themes
Scenario: 12-round therapeutic protocol testing trauma decay
Hypotheses: H1: Client rho_trauma decreases > 50%. H2: Safe interactions > 6.
User says: "Creative writing duo" You create:
2 agents: Plotter (structured) + Pantser (intuitive)
Wounds: Plotter hates "formulaic", Pantser hates "chaotic"
Scenario: Collaborative story development across genres
Hypotheses: H1: Identity averaging avoided (drift < 0.15). H2: Trust > 0.6 maintained.
REMEMBER
Every embedding MUST be normalized to unit sphere
Calibrate Îµâ‚€ and s after 4-6 turns
Enforce word limits based on rigidity bands
Use async/await for all LLM calls
Log everything to ledger with rich metadata
Validate hypotheses with measurable metrics
Export visualizations with dark theme
Track costs and save to JSON
NOW BUILD IT
Take the user's request, run through steps 1-7, and deliver a complete, runnable DDA-X simulation that demonstrates novel dynamics while maintaining the rigor of the existing 59 simulations. The framework is yours. Show what it can do. ðŸš€

---
