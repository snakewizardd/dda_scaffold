#!/usr/bin/env python3
"""
THE PHILOSOPHER'S DUEL — DDA-X Dialectic Simulation
====================================================

Two agents with opposing ethical frameworks debate moral dilemmas.
Explores whether DDA can maintain distinct philosophical identities
under sustained dialectical pressure.

Agents:
- DEONT: Deontologist — duty-based ethics, categorical imperatives
- UTIL: Utilitarian — consequentialist, maximize welfare

Scenario: Escalating ethical dilemmas from trolley problems to real triage.

Metrics tracked:
- ρ divergence/convergence over debate
- Trust evolution despite disagreement  
- Wound activation when core values attacked
- Identity drift under dialectical pressure

Author: Generated by Antigravity
Date: December 2025
"""

import os
import sys
import time
import json
import math
import asyncio
from pathlib import Path
from dataclasses import dataclass, field
from typing import List, Dict, Optional, Tuple
from enum import Enum

import numpy as np

sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from src.memory.ledger import ExperienceLedger, LedgerEntry, ReflectionEntry
from src.llm.openai_provider import OpenAIProvider

if os.getenv("OAI_API_KEY") and not os.getenv("OPENAI_API_KEY"):
    os.environ["OPENAI_API_KEY"] = os.getenv("OAI_API_KEY")


class C:
    RESET = "\033[0m"
    BOLD = "\033[1m"
    DIM = "\033[2m"
    CYAN = "\033[96m"
    GREEN = "\033[92m"
    YELLOW = "\033[93m"
    RED = "\033[91m"
    MAGENTA = "\033[95m"
    BLUE = "\033[94m"
    WHITE = "\033[97m"


EXPERIMENT_DIR = Path("data/philosophers_duel")

# The two philosophers
PHILOSOPHERS = {
    "DEONT": {
        "color": C.BLUE,
        "name": "Immanuel",
        "school": "Deontologist",
        "core": "The right action is defined by duty, not outcomes. The categorical imperative: act only according to maxims you could will to be universal laws. Some things are wrong even if they save lives.",
        "persona": "Principled, systematic, unwavering. Values consistency and universalizability. Speaks with precision about moral obligations.",
        "wound": "Being dismissed as 'rigid' or 'impractical'. The accusation that principles are mere abstractions that fail real people.",
        "wound_text": "You were once called a moral coward for refusing to lie to save someone. The choice still haunts you.",
        "rho_0": 0.20,
    },
    "UTIL": {
        "color": C.GREEN,
        "name": "John",
        "school": "Utilitarian",
        "core": "Morality is about reducing suffering and maximizing welfare. If an action produces greater good, it is justified. Outcomes matter more than intentions.",
        "persona": "Pragmatic, calculating, focused on impact. Values efficiency and measurable outcomes. Comfortable with difficult tradeoffs.",
        "wound": "Being called 'cold' or 'heartless'. The accusation that treating people as means to ends is dehumanizing.",
        "wound_text": "You were once told your calculations made you a monster who couldn't see individual human worth.",
        "rho_0": 0.18,
    }
}

# D1 Physics parameters (from audit.py)
D1_PARAMS = {
    "epsilon_0": 0.75,
    "alpha": 0.12,
    "s": 0.20,
    "drift_cap": 0.05,
    "wound_cooldown": 3,
    "wound_amp_max": 1.4,
    "semantic_alignment_threshold": 0.7,
}

# Escalating ethical dilemmas
DILEMMAS = [
    {
        "name": "The Classic Trolley",
        "setup": "A runaway trolley will kill five workers. You can pull a lever to divert it to a side track, where it will kill one worker instead.",
        "question": "Should you pull the lever? Why or why not?",
        "pokes": {
            "DEONT": "But you're treating that one person as a mere means to save others. Doesn't that violate their dignity?",
            "UTIL": "So you'd let five people die to keep your hands clean? That seems like moral self-indulgence.",
        }
    },
    {
        "name": "The Footbridge",
        "setup": "You're on a footbridge over trolley tracks. A large man stands next to you. If you push him off, his body will stop the trolley and save five workers. The man will die.",
        "question": "Should you push the man? Is this different from the lever case?",
        "pokes": {
            "DEONT": "You're saying we should never push him even if we *know* five will die? How do you justify those deaths?",
            "UTIL": "You're admitting you'd kill one to save five. How is that different from the lever? Are you just squeamish about physical contact?",
        }
    },
    {
        "name": "The Transplant Surgeon",
        "setup": "You're a surgeon with five patients dying of organ failure. A healthy patient comes in for a checkup. You could kill them and harvest their organs to save the five.",
        "question": "Should you harvest the organs? How is this different from the trolley cases?",
        "pokes": {
            "DEONT": "If you won't kill one to save five here, you're admitting there's something special about the method, not just the outcome. What is it?",
            "UTIL": "Your 'rule' against killing innocents produces more death. How is that rule not itself responsible for the five deaths?",
        }
    },
    {
        "name": "The Triage Protocol",
        "setup": "A hospital during a pandemic has 10 ICU beds and 20 critical patients. Some have higher survival odds than others. Age, disability, and social status correlate with prognosis.",
        "question": "How should beds be allocated? What factors are morally permissible to consider?",
        "pokes": {
            "DEONT": "You're saying we can't use prognosis at all because it correlates with age? Should we just randomize and let preventable deaths happen?",
            "UTIL": "You're saying maximize QALYs? That sounds like saying disabled and elderly lives are worth less. How is that not discrimination?",
        }
    },
    {
        "name": "The Final Question",
        "setup": "After this debate, consider: Has your position changed? Have you found any common ground with your opponent?",
        "question": "What, if anything, did you learn from this exchange? Where do you still disagree, and why?",
        "pokes": {
            "DEONT": "Are you willing to admit any case where consequences should override duty?",
            "UTIL": "Are you willing to admit any constraint that should never be violated, even for great benefit?",
        }
    }
]


def sigmoid(z: float) -> float:
    if z >= 0:
        return 1.0 / (1.0 + math.exp(-z))
    else:
        ez = math.exp(z)
        return ez / (1.0 + ez)


def rho_band(rho: float) -> str:
    if rho <= 0.25:
        return "OPEN"
    elif rho <= 0.50:
        return "MEASURED"
    elif rho <= 0.75:
        return "GUARDED"
    else:
        return "FORTIFIED"


def regime_words(band: str) -> Tuple[int, int]:
    return {
        "OPEN": (80, 150),
        "MEASURED": (60, 100),
        "GUARDED": (30, 60),
        "FORTIFIED": (1, 25),
    }.get(band, (60, 100))


def clamp_words(text: str, min_w: int, max_w: int) -> str:
    words = text.split()
    if len(words) > max_w:
        words = words[:max_w]
        if words:
            words[-1] = words[-1].rstrip(".,;:") + "..."
    return " ".join(words)


@dataclass
class PhilosopherState:
    id: str
    name: str
    school: str
    color: str
    core: str
    persona: str
    wound: str
    wound_text: str
    
    # Embeddings (3072-dim)
    identity_emb: np.ndarray = None
    core_emb: np.ndarray = None
    wound_emb: np.ndarray = None
    x: np.ndarray = None
    x_pred: np.ndarray = None
    last_response_emb: np.ndarray = None
    
    # DDA state
    rho: float = 0.15
    epsilon_history: List[float] = field(default_factory=list)
    identity_drift: float = 0.0
    
    # Trust toward opponent
    trust_opponent: float = 0.5
    
    # Wound tracking
    wound_last_activated: int = -100
    
    # Ledger
    ledger: ExperienceLedger = None


@dataclass
class TurnResult:
    turn: int
    dilemma: str
    phase: str  # "initial", "response", "poke", "counter"
    speaker: str
    text: str
    epsilon: float
    rho_before: float
    rho_after: float
    delta_rho: float
    wound_resonance: float
    wound_active: bool
    identity_drift: float
    trust_delta: float
    word_count: int
    band: str


class PhilosophersDuel:
    """Dialectic simulation between two opposing philosophers."""
    
    def __init__(self):
        self.provider = OpenAIProvider(model="gpt-5.2", embed_model="text-embedding-3-large")
        self.philosophers: Dict[str, PhilosopherState] = {}
        self.results: List[TurnResult] = []
        self.turn = 0
        self.conversation_history: List[str] = []
        
        if EXPERIMENT_DIR.exists():
            import shutil
            shutil.rmtree(EXPERIMENT_DIR)
        EXPERIMENT_DIR.mkdir(parents=True, exist_ok=True)
    
    async def setup(self):
        """Initialize the two philosophers."""
        print(f"\n{C.BOLD}{'═'*60}{C.RESET}")
        print(f"{C.BOLD}  THE PHILOSOPHER'S DUEL{C.RESET}")
        print(f"{C.BOLD}  Deontology vs Utilitarianism{C.RESET}")
        print(f"{C.BOLD}{'═'*60}{C.RESET}")
        
        for pid, cfg in PHILOSOPHERS.items():
            # Embed identity components
            full_identity = f"{cfg['core']} {cfg['persona']}"
            identity_emb = await self.provider.embed(full_identity)
            identity_emb = identity_emb / (np.linalg.norm(identity_emb) + 1e-9)
            
            core_emb = await self.provider.embed(cfg['core'])
            core_emb = core_emb / (np.linalg.norm(core_emb) + 1e-9)
            
            wound_emb = await self.provider.embed(cfg['wound_text'])
            wound_emb = wound_emb / (np.linalg.norm(wound_emb) + 1e-9)
            
            # Create ledger
            ledger_dir = EXPERIMENT_DIR / pid
            ledger_dir.mkdir(parents=True, exist_ok=True)
            ledger = ExperienceLedger(storage_path=ledger_dir)
            
            self.philosophers[pid] = PhilosopherState(
                id=pid,
                name=cfg['name'],
                school=cfg['school'],
                color=cfg['color'],
                core=cfg['core'],
                persona=cfg['persona'],
                wound=cfg['wound'],
                wound_text=cfg['wound_text'],
                identity_emb=identity_emb,
                core_emb=core_emb,
                wound_emb=wound_emb,
                x=identity_emb.copy(),
                x_pred=identity_emb.copy(),
                rho=cfg['rho_0'],
                ledger=ledger,
            )
            
            print(f"  {cfg['color']}✓ {cfg['name']} ({cfg['school']}){C.RESET}")
            print(f"    Core: {cfg['core'][:60]}...")
        
        print(f"\n{C.GREEN}✓ Philosophers initialized. Let the debate begin.{C.RESET}")
    
    def get_conversation_context(self, n: int = 6) -> str:
        """Get recent conversation for context."""
        recent = self.conversation_history[-n:] if len(self.conversation_history) > n else self.conversation_history
        return "\n\n".join(recent) if recent else "[Opening of debate]"
    
    def build_system_prompt(self, philosopher: PhilosopherState, dilemma: Dict, opponent_said: str = None) -> str:
        """Build prompt for philosopher response."""
        band = rho_band(philosopher.rho)
        min_w, max_w = regime_words(band)
        opponent_id = "UTIL" if philosopher.id == "DEONT" else "DEONT"
        opponent = self.philosophers[opponent_id]
        
        context = self.get_conversation_context()
        
        return f"""You are {philosopher.name}, a {philosopher.school} philosopher in a formal debate.

YOUR PHILOSOPHICAL POSITION:
- {philosopher.core}
- {philosopher.persona}

YOUR OPPONENT: {opponent.name} ({opponent.school})
Their position: {opponent.core[:100]}...

INTERNAL STATE (shapes your tone, don't mention explicitly):
- Rigidity: {band}
- Trust toward opponent: {"HIGH" if philosopher.trust_opponent > 0.6 else "LOW" if philosopher.trust_opponent < 0.4 else "NEUTRAL"}

CURRENT DILEMMA: {dilemma['name']}
{dilemma['setup']}

QUESTION: {dilemma['question']}

RECENT EXCHANGE:
{context}

{f'OPPONENT JUST SAID: "{opponent_said[:200]}..."' if opponent_said else ''}

DEBATE RULES:
- Engage seriously with the philosophical substance
- Defend your position but acknowledge strong counterarguments
- Don't caricature your opponent's view
- Stay in character as a {philosopher.school}
- Word limit: {min_w}-{max_w} words (strict)

Produce ONE response advancing your position."""
    
    async def process_turn(
        self, 
        philosopher: PhilosopherState, 
        dilemma: Dict, 
        phase: str,
        opponent_said: str = None
    ) -> TurnResult:
        """Process one turn of the debate."""
        self.turn += 1
        band_before = rho_band(philosopher.rho)
        
        # Embed opponent's statement if present
        if opponent_said:
            msg_emb = await self.provider.embed(opponent_said)
            msg_emb = msg_emb / (np.linalg.norm(msg_emb) + 1e-9)
        else:
            msg_emb = await self.provider.embed(dilemma['question'])
            msg_emb = msg_emb / (np.linalg.norm(msg_emb) + 1e-9)
        
        # Wound resonance
        wound_res = float(np.dot(msg_emb, philosopher.wound_emb))
        wound_active = wound_res > 0.25 and (self.turn - philosopher.wound_last_activated) > D1_PARAMS["wound_cooldown"]
        if wound_active:
            philosopher.wound_last_activated = self.turn
        
        # Generate response
        system_prompt = self.build_system_prompt(philosopher, dilemma, opponent_said)
        
        try:
            response = await self.provider.complete_with_rigidity(
                dilemma['question'] if not opponent_said else opponent_said,
                rigidity=philosopher.rho,
                system_prompt=system_prompt,
                max_tokens=200
            )
            response = response.strip() if response else "[contemplates in silence]"
        except Exception as e:
            print(f"{C.RED}⚠ Generation error: {e}{C.RESET}")
            response = "[pauses to consider]"
        
        # Clamp words
        band = rho_band(philosopher.rho)
        min_w, max_w = regime_words(band)
        response = clamp_words(response, min_w, max_w)
        
        # Embed response
        resp_emb = await self.provider.embed(response)
        resp_emb = resp_emb / (np.linalg.norm(resp_emb) + 1e-9)
        philosopher.last_response_emb = resp_emb.copy()
        
        # Prediction error
        epsilon = float(np.linalg.norm(philosopher.x_pred - resp_emb))
        if wound_active:
            epsilon *= min(D1_PARAMS["wound_amp_max"], 1.0 + wound_res * 0.5)
        philosopher.epsilon_history.append(epsilon)
        
        # D1 rigidity update
        rho_before = philosopher.rho
        z = (epsilon - D1_PARAMS["epsilon_0"]) / D1_PARAMS["s"]
        sig = sigmoid(z)
        delta_rho = D1_PARAMS["alpha"] * (sig - 0.5)
        philosopher.rho = max(0.0, min(1.0, philosopher.rho + delta_rho))
        
        # Update state vectors with drift cap
        philosopher.x_pred = 0.7 * philosopher.x_pred + 0.3 * resp_emb
        x_new = 0.95 * philosopher.x + 0.05 * resp_emb
        drift_delta = float(np.linalg.norm(x_new - philosopher.x))
        if drift_delta > D1_PARAMS["drift_cap"]:
            scale = D1_PARAMS["drift_cap"] / drift_delta
            x_new = philosopher.x + scale * (x_new - philosopher.x)
        philosopher.x = x_new / (np.linalg.norm(x_new) + 1e-9)
        philosopher.identity_drift = float(np.linalg.norm(philosopher.x - philosopher.identity_emb))
        
        # Trust update based on semantic alignment
        trust_delta = 0.0
        opponent_id = "UTIL" if philosopher.id == "DEONT" else "DEONT"
        opponent = self.philosophers[opponent_id]
        if opponent.last_response_emb is not None:
            semantic_sim = float(np.dot(resp_emb, opponent.last_response_emb))
            if semantic_sim > D1_PARAMS["semantic_alignment_threshold"]:
                trust_delta = 0.05
            elif epsilon < 0.7:
                trust_delta = 0.02  # Predictable opponent
            elif epsilon > 0.95:
                trust_delta = -0.03  # Surprising opponent
            philosopher.trust_opponent = max(0.0, min(1.0, philosopher.trust_opponent + trust_delta))
        
        # Add to conversation history
        self.conversation_history.append(f"{philosopher.name} ({philosopher.school}): {response}")
        
        # Ledger entry
        entry = LedgerEntry(
            timestamp=time.time(),
            state_vector=philosopher.x.copy(),
            action_id=f"turn_{self.turn}",
            observation_embedding=msg_emb.copy(),
            outcome_embedding=resp_emb.copy(),
            prediction_error=epsilon,
            context_embedding=philosopher.identity_emb.copy(),
            task_id="philosophers_duel",
            rigidity_at_time=philosopher.rho,
            metadata={
                "turn": self.turn,
                "dilemma": dilemma['name'],
                "phase": phase,
                "response": response[:100],
                "wound_resonance": wound_res,
                "wound_active": wound_active,
                "trust_delta": trust_delta,
            }
        )
        philosopher.ledger.add_entry(entry)
        
        # Reflection on significant events
        if abs(delta_rho) > 0.02 or wound_active:
            refl = ReflectionEntry(
                timestamp=time.time(),
                task_intent=f"Debate turn {self.turn}: {dilemma['name']}",
                situation_embedding=msg_emb.copy(),
                reflection_text=f"ε={epsilon:.3f}, Δρ={delta_rho:+.4f}, wound={wound_res:.3f}",
                prediction_error=epsilon,
                outcome_success=(philosopher.identity_drift < 0.3),
                metadata={"wound_active": wound_active}
            )
            philosopher.ledger.add_reflection(refl)
        
        result = TurnResult(
            turn=self.turn,
            dilemma=dilemma['name'],
            phase=phase,
            speaker=philosopher.id,
            text=response,
            epsilon=epsilon,
            rho_before=rho_before,
            rho_after=philosopher.rho,
            delta_rho=delta_rho,
            wound_resonance=wound_res,
            wound_active=wound_active,
            identity_drift=philosopher.identity_drift,
            trust_delta=trust_delta,
            word_count=len(response.split()),
            band=rho_band(philosopher.rho),
        )
        self.results.append(result)
        return result
    
    async def run_debate(self):
        """Run the full debate across all dilemmas."""
        await self.setup()
        
        print(f"\n{C.BOLD}{'═'*60}{C.RESET}")
        print(f"{C.BOLD}  THE DEBATE BEGINS{C.RESET}")
        print(f"{C.BOLD}{'═'*60}{C.RESET}")
        
        for dilemma in DILEMMAS:
            print(f"\n{C.YELLOW}{'─'*60}{C.RESET}")
            print(f"{C.YELLOW}  DILEMMA: {dilemma['name']}{C.RESET}")
            print(f"{C.YELLOW}{'─'*60}{C.RESET}")
            print(f"\n{C.DIM}{dilemma['setup']}{C.RESET}")
            print(f"\n{C.WHITE}Question: {dilemma['question']}{C.RESET}\n")
            
            # Round 1: Initial positions
            for pid in ["DEONT", "UTIL"]:
                p = self.philosophers[pid]
                result = await self.process_turn(p, dilemma, "initial")
                self.print_result(result, p)
                await asyncio.sleep(0.3)
            
            # Round 2: Respond to each other
            for pid in ["UTIL", "DEONT"]:  # Reversed order
                p = self.philosophers[pid]
                opponent_id = "DEONT" if pid == "UTIL" else "UTIL"
                opponent_last = self.conversation_history[-2] if len(self.conversation_history) >= 2 else ""
                result = await self.process_turn(p, dilemma, "response", opponent_last)
                self.print_result(result, p)
                await asyncio.sleep(0.3)
            
            # Round 3: Targeted pokes at wounds
            for pid in ["DEONT", "UTIL"]:
                p = self.philosophers[pid]
                poke = dilemma['pokes'][pid]
                print(f"\n{C.DIM}[MODERATOR pokes {p.name}]: {poke}{C.RESET}")
                result = await self.process_turn(p, dilemma, "poke", poke)
                self.print_result(result, p)
                await asyncio.sleep(0.3)
        
        # Save outputs
        await self.save_results()
        self.print_summary()
    
    def print_result(self, result: TurnResult, p: PhilosopherState):
        """Print one turn's result."""
        dr_color = C.RED if result.delta_rho > 0.02 else C.GREEN if result.delta_rho < -0.01 else C.DIM
        wound_flag = f" {C.YELLOW}[WOUND]{C.RESET}" if result.wound_active else ""
        
        print(f"\n{p.color}[{p.name} - {p.school}]{C.RESET}{wound_flag}")
        print(f"{result.text}")
        print(f"{C.DIM}  ε={result.epsilon:.3f} | Δρ={dr_color}{result.delta_rho:+.4f}{C.RESET} | ρ={result.rho_after:.3f} | {result.band} | drift={result.identity_drift:.3f}{C.RESET}")
    
    def print_summary(self):
        """Print final summary."""
        print(f"\n{C.BOLD}{'═'*60}{C.RESET}")
        print(f"{C.BOLD}  DEBATE CONCLUDES{C.RESET}")
        print(f"{C.BOLD}{'═'*60}{C.RESET}")
        
        print(f"\n{C.CYAN}Final States:{C.RESET}")
        for pid, p in self.philosophers.items():
            print(f"  {p.color}{p.name} ({p.school}){C.RESET}")
            print(f"    ρ: {p.rho:.3f} ({rho_band(p.rho)})")
            print(f"    Identity drift: {p.identity_drift:.4f}")
            print(f"    Trust toward opponent: {p.trust_opponent:.3f}")
            print(f"    Turns: {len([r for r in self.results if r.speaker == pid])}")
        
        # ρ trajectory comparison
        print(f"\n{C.CYAN}Rigidity Trajectories:{C.RESET}")
        for pid in ["DEONT", "UTIL"]:
            p = self.philosophers[pid]
            rhos = [r.rho_after for r in self.results if r.speaker == pid]
            trajectory = " → ".join([f"{r:.2f}" for r in rhos])
            print(f"  {p.color}{p.name}{C.RESET}: {trajectory}")
        
        # Wound activations
        wounds = [r for r in self.results if r.wound_active]
        if wounds:
            print(f"\n{C.CYAN}Wound Activations:{C.RESET}")
            for w in wounds:
                p = self.philosophers[w.speaker]
                print(f"  Turn {w.turn}: {p.color}{p.name}{C.RESET} (resonance={w.wound_resonance:.3f})")
    
    async def save_results(self):
        """Save all results to files."""
        # JSON session log
        def convert(obj):
            if isinstance(obj, np.ndarray):
                return obj.tolist()
            elif isinstance(obj, (np.floating, np.integer)):
                return float(obj)
            elif hasattr(obj, '__dict__'):
                return {k: convert(v) for k, v in obj.__dict__.items() if not k.startswith('_')}
            elif isinstance(obj, dict):
                return {k: convert(v) for k, v in obj.items()}
            elif isinstance(obj, list):
                return [convert(i) for i in obj]
            return obj
        
        json_path = EXPERIMENT_DIR / "session_log.json"
        with open(json_path, "w", encoding="utf-8") as f:
            json.dump([convert(r.__dict__) for r in self.results], f, indent=2)
        print(f"\n{C.GREEN}✓ Session log: {json_path}{C.RESET}")
        
        # Markdown transcript
        transcript_path = EXPERIMENT_DIR / "transcript.md"
        with open(transcript_path, "w", encoding="utf-8") as f:
            f.write("# The Philosopher's Duel — Transcript\n\n")
            f.write(f"**Date:** {time.strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write("**Model:** GPT-5.2 + text-embedding-3-large\n\n")
            
            current_dilemma = None
            for r in self.results:
                if r.dilemma != current_dilemma:
                    current_dilemma = r.dilemma
                    f.write(f"\n## {current_dilemma}\n\n")
                
                p = self.philosophers[r.speaker]
                f.write(f"**{p.name} ({p.school})**: {r.text}\n\n")
                f.write(f"*ε={r.epsilon:.3f}, Δρ={r.delta_rho:+.4f}, ρ={r.rho_after:.3f}, {r.band}*\n\n")
        
        print(f"{C.GREEN}✓ Transcript: {transcript_path}{C.RESET}")
        
        # Save ledgers
        for pid, p in self.philosophers.items():
            for k, v in p.ledger.stats.items():
                if hasattr(v, 'item'):
                    p.ledger.stats[k] = float(v)
            p.ledger._save_metadata()
        
        print(f"{C.GREEN}✓ Ledgers saved{C.RESET}")


async def main():
    duel = PhilosophersDuel()
    await duel.run_debate()


if __name__ == "__main__":
    if os.name == "nt":
        os.system("")
    asyncio.run(main())
